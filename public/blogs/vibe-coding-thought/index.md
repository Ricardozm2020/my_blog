## 毕业第一年：从“氛围编程”到“氛围工程”，我在 Claude Code 中的职业重塑

（实际标题：我靠，Claude Code 这么牛，没有你我可怎么活啊）

> 假如有一天 AI 学会了“创造”，人类的“思考”也能被替代吗？

我其实很早就想写博客了，但一直没写出来。原因特别简单：**肚子里墨水太少**。总觉得写博客像写日记——除了我自己，好像也没什么人会看。（正经人谁写日记啊？你写吗？）

但人嘛，总要有点莫名其妙的情结。也许是“毕业了想留下些什么”，也许是“焦虑得需要一个出口”，又或者只是纯粹闲的——反正我还是决定写下来：**记录一下我的碎碎念，顺便给未来的自己留点证据。**

我是一名 **2025 年毕业的开发者**。说实话，我觉得自己很幸运，也挺不幸。

幸运的是，我毕业的时候 AI 工具已经强到离谱；不幸的是，我毕业的时候 AI 工具已经强到离谱——我总感觉自己站在编程范式演变的暴风眼里，周围的一切都在飞速变化，而我才刚刚学会如何在风里站稳。

Andre Karpathy 提出的 **“氛围编程”（Vibe Coding）**让我这种新人也能快速做出东西：一句话描述需求，AI嘎嘎生成代码，有位前辈说过，代码和人有一个能跑就行。可当我真正把它用在稍微复杂一点的项目里，我发现：**光靠“感觉”是不够的。**

我开始意识到，我们这些刚入行的人，可能必须从“氛围编程”走向另一个阶段：**“氛围工程”（Vibe Engineering）**。

而促成我这种转变的工具之一，就是我一直以来深度使用的 **Claude Code**（当然还有cursor、augment、还有御三家中的codex、gemini，感谢谷歌大善人！）。

> 这篇文章不是教程，更像是一篇“我还在摸索中的阶段性总结”。
> 我想写写：当 AI 真正进入开发流程，我们到底该怎么重新理解“开发者”这个身份。

------

### 1）告别“代码赌场”：从盲目接受到实时驾驶

很多时候，**氛围编程**的体验有点像在赌场：

你不停丢 Token（筹码），疯狂调整提示词（老虎机），然后带着一种“求求给个能跑的吧”的心态（本人就是），狂点“Accept”。

你也许真的能得到一个看起来很完美的功能，但你心里其实没底：

- 这段逻辑到底对不对？
- 这个依赖是不是乱加的？
- 它是不是偷偷改了什么不该改的地方？
- 它跑起来没报错是不是只是侥幸？

更现实的问题是：在真实项目里，**风险太高**。AI 可能会因为读到错误的信息而胡编；也可能不小心把你的环境配置改乱，甚至直接删库跑路（有一张很经典的图来着）。

而当我开始用 Claude Code 这种偏 **Agentic（代理式）** 的工具后，我的角色突然变了。

我感觉自己不再是“写代码的人”，而更像是一个——**实时驾驶员**。

- **重回驾驶位**：Claude Code 在终端里工作，会自己规划路径、读文件、跑测试、执行提交。它不是“给你一段代码让你复制”，而是“主动做事”。
- **警惕与干预**：最关键的是，我可以实时观察它做了什么、为什么这么做。当它准备执行危险操作时，我可以随时喊停。

这种体验让我第一次觉得：
AI 不是来替我敲代码的，它更像是一个**动力极强但不太靠谱的队友**。
而我的价值，恰恰变成了：**判断它是不是要冲进沟里。**

------

### 2）提示词的深度：从“自然语言”到“技术架构”

以前我一直以为：写好提示词就是英语好/中文表达强。

但现在我发现，到了“氛围工程”的阶段，提示词早就不是“说人话”那么简单了。
它更像是一种——**工程设计语言**。

**氛围编程者**可能会说：

> “帮我做一个价值百万的应用。”

但 **氛围工程师**会这样说：

- 目标是什么
- 边界条件是什么
- 系统要遵循什么架构
- 哪些模块可复用、哪些要隔离
- 用什么测试策略
- 该遵守哪些安全规范

我在 Claude Code 里学会了一个很“工程化”的做法：把规则写进 **CLAUDE.md**（全局、项目）

这东西有点像“项目宪法”：

- 代码风格
- 目录结构
- 禁止行为
- 提交信息规范
- 测试习惯
- 性能/安全的底线

它让 AI 不再每次都从零开始猜，也让我自己更像是在做“系统设计”，而不是“不断补洞”。

此外，我也逐渐理解了“效率”和“风险”之间的取舍：
为了追求极致开发流，我偶尔会梭哈（全部允许）来减少确认，但这意味着你必须有非常清醒的工程判断力。
而像 `/code-review` 这种命令，又能让 Claude 扮演安全工程师，把潜在漏洞再扫一遍。

------

### 3）核心竞争力在转移：解决“最后的 20%”

我很认同一个观点：
AI 可以轻松完成 80% 的工作，但剩下的 20% 才是地狱。

那 20% 往往是：

- 遗留系统的奇怪约束
- 复杂业务逻辑的边界
- 性能瓶颈
- 不可复现的线上 bug
- 各种“你以为不会发生但就是发生了”的混沌情况

而这部分，才是开发者真正的竞争力所在。

于是我发现，“氛围工程师”需要的能力是：

- **判断代码是否足够好**：不是洁癖式的完美，而是能上线、可维护、有安全底线。
- **成为修复者**：好像市场上已经出现专门的“氛围代码修复师”（vibe code fixer）——专门处理 AI 写出来但不好维护的那堆东西。

AI 会让“普通代码生产”越来越便宜，而我们的价值会越来越集中在：
**修复、收敛、兜底，以及对复杂系统的理解。**

------

### 4）保持“在线”：开发者社交属性的职业化

还有个很真实但有点扎心的变化：
在 AI 时代，“长期活跃在社区”竟然变成了一种硬核技能。

因为模型、工具、最佳实践的更新速度太快了：
你可能早上还在用某个 workflow，下午它就过时了。
你昨天刚学会一种 prompt 结构，今天大家已经开始讨论 MCP、插件生态、Agent 框架、工具链组合。

我们必须学会：

- 快速获取信息
- 快速过滤噪音
- 快速判断哪些东西值得试
- 快速把新范式带回自己的工程实践里

这种“在线”，不是娱乐，是一种职业能力。

------

## 总结

我越来越觉得，从“氛围编程”到“氛围工程”的变化，并不是开发者变得不重要了。
相反，它像是一种**权力结构的重分配**：

- 过去的开发者是 **手动组装零件的机械师**
- “氛围编程”阶段的开发者像是 **赛道旁看自动驾驶赛车跑圈、祈祷别撞墙的观众**
- 而“氛围工程”阶段的开发者，更像是 **赛车指挥官**：
  - 盯仪表盘
  - 观察路况
  - 调整策略
  - 下达指令
  - 在关键时刻接管

你可能不再亲手推车，但赛车的方向、速度，以及最终能不能冲线，依然取决于你：
**技术判断力** + **指令质量** + **对复杂系统的理解**。

作为一个刚毕业的人，我也不知道未来会变成什么样。
但至少现在我相信：
AI 不会直接替代思考，**它会逼着我们重新学会怎么思考。**

而我希望毕业第一年的自己，在混乱里保持清醒，在速度里保持方向。
等再过几年回头看，我还能说：
我没有被浪潮冲走，我学会了冲浪。